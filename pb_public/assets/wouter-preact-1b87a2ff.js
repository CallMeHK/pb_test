import{_ as S,s as m,p as E,h as P,q as w}from"./@preact/signals-4e3ecbd2.js";import{B as $,h as k,i as C,q,a as A}from"./preact-bfe5487e.js";function p(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}function b(t,e){const o=e(),[{_instance:n},s]=E({_instance:{_value:o,_getSnapshot:e}});return m(()=>{n._value=o,n._getSnapshot=e,p(n._value,e())||s({_instance:n})},[t,o,e]),P(()=>(p(n._value,n._getSnapshot())||s({_instance:n}),t(()=>{p(n._value,n._getSnapshot())||s({_instance:n})})),[t]),o}const y=t=>{const e=S([t,(...o)=>e[0](...o)]).current;return m(()=>{e[0]=t}),e[1]},F=(t="",e=location.pathname)=>e.toLowerCase().indexOf(t.toLowerCase())?"~"+e:e.slice(t.length)||"/",H=(t,e="")=>t[0]==="~"?t.slice(1):e+t,I="popstate",v="pushState",g="replaceState",M="hashchange",R=[I,v,g,M],T=t=>{for(const e of R)addEventListener(e,t);return()=>{for(const e of R)removeEventListener(e,t)}},U=t=>b(T,t),z=()=>location.pathname,B=()=>U(z),O=(t,{replace:e=!1}={})=>history[e?g:v](null,"",t),Z=(t={})=>[F(t.base,B()),y((e,o)=>O(H(e,t.base),o))];if(typeof history<"u")for(const t of[v,g]){const e=history[t];history[t]=function(){const o=e.apply(this,arguments),n=new Event(t);return n.arguments=arguments,dispatchEvent(n),o}}function j(t=G){let e={};const o=n=>e[n]||(e[n]=t(n));return(n,s)=>{const{regexp:r,keys:a}=o(n||""),u=r.exec(s);return u?[!0,a.reduce((i,l,h)=>(i[l.name]=u[h+1],i),{})]:[!1,null]}}const _=t=>t.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1"),D=(t,e,o)=>{let n=t?"((?:[^\\/]+?)(?:\\/(?:[^\\/]+?))*)":"([^\\/]+?)";return e&&o&&(n="(?:\\/"+n+")"),n+(e?"?":"")},G=t=>{const e=/:([A-Za-z0-9_]+)([?+*]?)/g;let o=null,n=0,s=[],r="";for(;(o=e.exec(t))!==null;){const[a,u,c]=o,i=c==="+"||c==="*",l=c==="?"||c==="*",h=l&&t[o.index-1]==="/"?1:0,L=t.substring(n,o.index-h);s.push({name:u}),n=e.lastIndex,r+=_(L)+D(i,l,h)}return r+=_(t.substring(n)),{keys:s,regexp:new RegExp("^"+r+"(?:\\/)?$","i")}},J={hook:Z,matcher:j(),base:""},K=$(J),d=()=>w(K),x=t=>t.hook(t),N=()=>x(d()),Q=t=>{const e=d(),[o]=x(e);return e.matcher(t,o)},X=({path:t,match:e,component:o,children:n})=>{const s=Q(t),[r,a]=e||s;return r?o?k(o,{params:a}):typeof n=="function"?n(a):n:null},f=t=>Array.isArray(t)?[].concat(...t.map(e=>e&&e.type===A?f(e.props.children):f(e))):[t],Y=({children:t,location:e})=>{const o=d(),n=o.matcher,[s]=x(o);for(const r of f(t)){let a=0;if(C(r)&&(a=r.props.path?n(r.props.path,e||s):[!0,{}])[0])return q(r,{match:a})}return null},tt=t=>{const{to:e,href:o=e}=t,[,n]=N(),s=y(()=>n(e||o,t));return m(()=>{s()},[]),null};export{X as R,Y as S,tt as a,N as u};
